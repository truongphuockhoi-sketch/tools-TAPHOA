<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video to Prompt - AI Tools Hub</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            padding: 20px 0;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 30px;
        }
        
        /* Token Section - Thu g·ªçn */
        .token-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .token-header {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.3s ease;
        }

        .token-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .token-icon {
            font-size: 1.2rem;
        }

        .token-title {
            font-weight: bold;
            flex-grow: 1;
        }

        .token-arrow {
            transition: transform 0.3s ease;
            font-size: 0.9rem;
        }

        .token-section.expanded .token-arrow {
            transform: rotate(180deg);
        }

        .token-status {
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: #666;
        }

        .token-status.has-token {
            background: #4ecdc4;
        }

        .token-content {
            display: none;
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .token-section.expanded .token-content {
            display: block;
        }

        .token-instruction {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .token-instruction ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .token-instruction li {
            margin-bottom: 5px;
        }

        .token-instruction a {
            color: #4ecdc4;
            text-decoration: none;
        }

        .token-instruction a:hover {
            text-decoration: underline;
        }

        .token-input-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .token-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .token-btn {
            background: #4ecdc4;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
            flex: 1;
            justify-content: center;
        }

        .token-btn:hover {
            background: #3dbeb5;
            transform: translateY(-2px);
        }

        .token-btn-clear {
            background: #666;
        }

        .token-btn-clear:hover {
            background: #555;
        }

        .token-btn-close {
            background: #ff6b6b;
            flex: 0.5;
        }

        .token-btn-close:hover {
            background: #ff5252;
        }

        .token-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 5px;
            border-left: 3px solid #4caf50;
        }

        .token-info p {
            margin: 0;
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .btn-icon {
            font-size: 1rem;
        }

        /* Upload Area */
        .upload-area {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .upload-area.dragover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ff6b6b;
        }
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        /* Buttons */
        .btn {
            background: #ff6b6b;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }
        .btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: transparent;
            border: 2px solid #ff6b6b;
        }
        
        /* Video Preview */
        .video-preview {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .video-preview video {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
        }
        
        /* Loading */
        .loading {
            display: none;
            text-align: center;
            margin: 30px 0;
        }
        .loading-spinner {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid #ff6b6b;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Results */
        .results {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
        }
        .result-section {
            margin-bottom: 25px;
        }
        .result-section h3 {
            margin-bottom: 15px;
            color: #ff6b6b;
        }
        .prompt-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ff6b6b;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: monospace;
        }
        .copy-btn {
            background: #4ecdc4;
            margin-top: 10px;
        }
        .copy-btn:hover {
            background: #3dbeb5;
        }
        
        /* Features */
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }
        .feature-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .feature-card .icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        /* Loading chi ti·∫øt */
        .loading-details {
            margin-top: 20px;
            text-align: left;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9rem;
        }

        .loading-step {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-icon {
            width: 20px;
            text-align: center;
        }
        
        /* Token Auto-check */
        .token-auto-check {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .token-auto-check input {
            width: 16px;
            height: 16px;
        }
        
        /* Analysis Options */
        .analysis-options {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .option-group {
            margin-bottom: 15px;
        }
        
        .option-label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .option-description {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .option-select {
            width: 100%;
            padding: 8px 12px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .option-select option {
            background: #4a5568;
            color: white;
        }
        
        .speed-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
            background: #4caf50;
        }
        
        .speed-indicator.slow {
            background: #ff9800;
        }
        
        .speed-indicator.fast {
            background: #4caf50;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üé¨ Video to Prompt</h1>
            <p class="subtitle">Chuy·ªÉn ƒë·ªïi video th√†nh prompt AI ch·∫•t l∆∞·ª£ng cao ho√†n to√†n mi·ªÖn ph√≠</p>
        </header>

        <!-- V√ôNG NH·∫¨P TOKEN - THI·∫æT K·∫æ THU G·ªåN -->
        <div class="token-section">
            <div class="token-header" onclick="toggleTokenSection()">
                <span class="token-icon">üîë</span>
                <span class="token-title">Hugging Face Token</span>
                <span class="token-arrow">‚ñº</span>
                <span class="token-status" id="tokenStatus"></span>
            </div>
            
            <div class="token-content" id="tokenContent">
                <div class="token-instruction">
                    <p>ƒê·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng AI th·∫≠t, vui l√≤ng nh·∫≠p token c·ªßa b·∫°n:</p>
                    <ol>
                        <li>Truy c·∫≠p <a href="https://huggingface.co/settings/tokens" target="_blank">Hugging Face Tokens</a></li>
                        <li>T·∫°o token m·ªõi v·ªõi quy·ªÅn "read"</li>
                        <li>D√°n token v√†o √¥ b√™n d∆∞·ªõi</li>
                    </ol>
                </div>
                
                <div class="token-input-group">
                    <input type="password" id="hfToken" class="token-input" placeholder="hf_xxxxxxxxxxxxxxxx">
                    <div class="token-buttons">
                        <button class="token-btn" onclick="saveToken()">
                            <span class="btn-icon">üíæ</span>
                            L∆∞u Token
                        </button>
                        <button class="token-btn token-btn-clear" onclick="clearToken()">
                            <span class="btn-icon">üóëÔ∏è</span>
                            X√≥a
                        </button>
                        <button class="token-btn token-btn-close" onclick="toggleTokenSection()">
                            <span class="btn-icon">‚úï</span>
                            ƒê√≥ng
                        </button>
                    </div>
                </div>
                
                <div class="token-auto-check">
                    <input type="checkbox" id="autoCheckToken" checked>
                    <label for="autoCheckToken">T·ª± ƒë·ªông ki·ªÉm tra token tr∆∞·ªõc khi ph√¢n t√≠ch</label>
                </div>
                
                <div class="token-info">
                    <p>‚úÖ Token ƒë∆∞·ª£c l∆∞u c·ª•c b·ªô tr√™n tr√¨nh duy·ªát - an to√†n & b·∫£o m·∫≠t</p>
                </div>
            </div>
        </div>

        <!-- Upload Area -->
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÅ</div>
            <h2>K√©o th·∫£ video v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</h2>
            <p>H·ªó tr·ª£ MP4, MOV, AVI (t·ªëi ƒëa 50MB)</p>
            <input type="file" id="videoInput" accept="video/*" style="display: none;">
        </div>

        <!-- Video Preview -->
        <div class="video-preview" id="videoPreview">
            <video controls id="previewVideo"></video>
            
            <!-- Analysis Options -->
            <div class="analysis-options">
                <h3 style="margin-bottom: 15px; color: #ff6b6b;">T√πy ch·ªçn ph√¢n t√≠ch</h3>
                
                <div class="option-group">
                    <label class="option-label">
                        Ph∆∞∆°ng ph√°p ph√¢n t√≠ch:
                        <span class="speed-indicator fast" id="speedIndicator">Nhanh</span>
                    </label>
                    <select class="option-select" id="analysisMethod">
                        <option value="fast">Ph√¢n t√≠ch nhanh (1-2 khung h√¨nh)</option>
                        <option value="balanced">C√¢n b·∫±ng (3-4 khung h√¨nh)</option>
                        <option value="detailed">Chi ti·∫øt (5-6 khung h√¨nh)</option>
                    </select>
                    <div class="option-description">
                        Ch·ªçn ph∆∞∆°ng ph√°p ph√¢n t√≠ch ph√π h·ª£p v·ªõi nhu c·∫ßu c·ªßa b·∫°n. Ph√¢n t√≠ch nhanh ph√π h·ª£p cho vi·ªác t√¨m √Ω t∆∞·ªüng nhanh ch√≥ng.
                    </div>
                </div>
                
                <div class="option-group">
                    <label class="option-label">Lo·∫°i prompt mong mu·ªën:</label>
                    <select class="option-select" id="promptType">
                        <option value="creative">S√°ng t·∫°o (ph√π h·ª£p cho √Ω t∆∞·ªüng m·ªõi)</option>
                        <option value="descriptive">M√¥ t·∫£ chi ti·∫øt</option>
                        <option value="technical">K·ªπ thu·∫≠t (ph√π h·ª£p cho AI video)</option>
                    </select>
                </div>
            </div>
            
            <div>
                <button class="btn" id="analyzeBtn">Ph√¢n t√≠ch Video</button>
                <button class="btn btn-secondary" id="changeVideoBtn">Ch·ªçn video kh√°c</button>
            </div>
        </div>

        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p id="loadingText">üîÑ ƒêang ph√¢n t√≠ch video v√† t·∫°o prompt ch√≠nh x√°c...</p>
            
            <div class="loading-details">
                <div class="loading-step">
                    <span class="step-icon">üé¨</span>
                    <span id="step1">Tr√≠ch xu·∫•t khung h√¨nh t·ª´ video</span>
                </div>
                <div class="loading-step">
                    <span class="step-icon">ü§ñ</span>
                    <span id="step2">Ph√¢n t√≠ch n·ªôi dung v·ªõi AI</span>
                </div>
                <div class="loading-step">
                    <span class="step-icon">‚ú®</span>
                    <span id="step3">T·∫°o prompt ch√≠nh x√°c</span>
                </div>
            </div>
            
            <p style="margin-top: 15px; font-size: 0.9rem; opacity: 0.8;">
                Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t 1-2 ph√∫t t√πy v√†o ƒë·ªô d√†i video
            </p>
        </div>

        <!-- Results -->
        <div class="results" id="results">
            <div class="result-section">
                <h3>üéØ Prompt ch√≠nh (d√†nh cho AI Image Generation)</h3>
                <div class="prompt-box" id="mainPrompt"></div>
                <button class="btn copy-btn" onclick="copyToClipboard('mainPrompt')">Sao ch√©p Prompt ch√≠nh</button>
            </div>
            
            <div class="result-section">
                <h3>üìù Prompt chi ti·∫øt (d√†nh cho AI Video)</h3>
                <div class="prompt-box" id="detailedPrompt"></div>
                <button class="btn copy-btn" onclick="copyToClipboard('detailedPrompt')">Sao ch√©p Prompt chi ti·∫øt</button>
            </div>
            
            <div class="result-section">
                <h3>üè∑Ô∏è Tags & Keywords</h3>
                <div class="prompt-box" id="tagsPrompt"></div>
                <button class="btn copy-btn" onclick="copyToClipboard('tagsPrompt')">Sao ch√©p Tags</button>
            </div>

            <button class="btn btn-secondary" onclick="resetApp()">Ph√¢n t√≠ch video m·ªõi</button>
        </div>

        <!-- Features -->
        <div class="features">
            <div class="feature-card">
                <div class="icon">‚ö°</div>
                <h3>T·ªëc ƒë·ªô t·ªëi ∆∞u</h3>
                <p>Ph√¢n t√≠ch nhanh ch√≥ng v·ªõi thu·∫≠t to√°n t·ªëi ∆∞u</p>
            </div>
            <div class="feature-card">
                <div class="icon">üé®</div>
                <h3>Multi-Format Prompts</h3>
                <p>T·∫°o prompt cho c·∫£ AI image v√† video generation</p>
            </div>
            <div class="feature-card">
                <div class="icon">ü§ñ</div>
                <h3>AI-Powered Analysis</h3>
                <p>S·ª≠ d·ª•ng AI ƒë·ªÉ ph√¢n t√≠ch n·ªôi dung video chuy√™n s√¢u</p>
            </div>
            <div class="feature-card">
                <div class="icon">üíØ</div>
                <h3>100% Mi·ªÖn ph√≠</h3>
                <p>Kh√¥ng gi·ªõi h·∫°n s·ªë l·∫ßn s·ª≠ d·ª•ng</p>
            </div>
        </div>
    </div>

    <script>
        // üî¥ H√ÄM QU·∫¢N L√ù TOKEN & GIAO DI·ªÜN
        function toggleTokenSection() {
            const tokenSection = document.querySelector('.token-section');
            tokenSection.classList.toggle('expanded');
        }

        function updateTokenStatus() {
            const tokenStatus = document.getElementById('tokenStatus');
            const savedToken = localStorage.getItem('hfToken');
            
            if (savedToken) {
                tokenStatus.textContent = 'ƒê√£ l∆∞u';
                tokenStatus.classList.add('has-token');
            } else {
                tokenStatus.textContent = 'Ch∆∞a c√≥';
                tokenStatus.classList.remove('has-token');
            }
        }

        function saveToken() {
            const tokenInput = document.getElementById('hfToken');
            const token = tokenInput.value;
            
            if (token && token.startsWith('hf_')) {
                localStorage.setItem('hfToken', token);
                alert('‚úÖ Token ƒë√£ ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng!');
                tokenInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                updateTokenStatus();
                setTimeout(() => toggleTokenSection(), 1000);
            } else {
                alert('‚ùå Token kh√¥ng h·ª£p l·ªá! Token ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng "hf_"');
            }
        }

        function clearToken() {
            localStorage.removeItem('hfToken');
            document.getElementById('hfToken').value = '';
            alert('‚úÖ Token ƒë√£ ƒë∆∞·ª£c x√≥a!');
            updateTokenStatus();
        }

        // Ki·ªÉm tra token c√≥ h·ª£p l·ªá kh√¥ng
        async function validateToken(token) {
            if (!token) return false;
            
            try {
                const response = await fetch(
                    'https://api-inference.huggingface.co/models/Salesforce/blip-image-captioning-large',
                    {
                        headers: { Authorization: `Bearer ${token}` },
                        method: 'POST',
                        body: JSON.stringify({inputs: "test"}),
                    }
                );
                
                // N·∫øu token h·ª£p l·ªá, API s·∫Ω tr·∫£ v·ªÅ l·ªói 400 (Bad Request) thay v√¨ 401 (Unauthorized)
                return response.status !== 401;
            } catch (error) {
                console.error('Token validation error:', error);
                return false;
            }
        }

        // Load token status khi trang ƒë∆∞·ª£c t·∫£i
        window.addEventListener('load', async function() {
            const savedToken = localStorage.getItem('hfToken');
            const tokenInput = document.getElementById('hfToken');
            
            if (savedToken) {
                tokenInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
            }
            
            updateTokenStatus();
            
            // Ki·ªÉm tra token khi trang t·∫£i n·∫øu c√≥ token ƒë√£ l∆∞u
            if (savedToken) {
                const isValid = await validateToken(savedToken);
                if (!isValid) {
                    alert('‚ö†Ô∏è Token ƒë√£ l∆∞u kh√¥ng c√≤n h·ª£p l·ªá. Vui l√≤ng nh·∫≠p token m·ªõi.');
                    localStorage.removeItem('hfToken');
                    updateTokenStatus();
                    document.getElementById('hfToken').value = '';
                    toggleTokenSection();
                }
            }
            
            // C·∫≠p nh·∫≠t ch·ªâ b√°o t·ªëc ƒë·ªô
            updateSpeedIndicator();
        });

        // Elements
        const uploadArea = document.getElementById('uploadArea');
        const videoInput = document.getElementById('videoInput');
        const videoPreview = document.getElementById('videoPreview');
        const previewVideo = document.getElementById('previewVideo');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const changeVideoBtn = document.getElementById('changeVideoBtn');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        const mainPrompt = document.getElementById('mainPrompt');
        const detailedPrompt = document.getElementById('detailedPrompt');
        const tagsPrompt = document.getElementById('tagsPrompt');
        const analysisMethod = document.getElementById('analysisMethod');
        const promptType = document.getElementById('promptType');
        const speedIndicator = document.getElementById('speedIndicator');

        let currentVideoFile = null;

        // Event Listeners
        uploadArea.addEventListener('click', () => videoInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        
        videoInput.addEventListener('change', handleFileSelect);
        analyzeBtn.addEventListener('click', analyzeVideo);
        changeVideoBtn.addEventListener('click', () => videoInput.click());
        analysisMethod.addEventListener('change', updateSpeedIndicator);

        // Functions
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('video/')) {
                handleVideoFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleVideoFile(e.target.files[0]);
            }
        }

        function handleVideoFile(file) {
            if (file.size > 50 * 1024 * 1024) {
                alert('Video qu√° l·ªõn! Vui l√≤ng ch·ªçn video nh·ªè h∆°n 50MB.');
                return;
            }

            currentVideoFile = file;
            const videoURL = URL.createObjectURL(file);
            previewVideo.src = videoURL;
            uploadArea.style.display = 'none';
            videoPreview.style.display = 'block';
            results.style.display = 'none';
        }

        function updateSpeedIndicator() {
            const method = analysisMethod.value;
            const indicator = document.getElementById('speedIndicator');
            
            if (method === 'fast') {
                indicator.textContent = 'Nhanh';
                indicator.className = 'speed-indicator fast';
            } else if (method === 'balanced') {
                indicator.textContent = 'C√¢n b·∫±ng';
                indicator.className = 'speed-indicator';
            } else {
                indicator.textContent = 'Chi ti·∫øt';
                indicator.className = 'speed-indicator slow';
            }
        }

        // üî¥ PH√ÇN T√çCH VIDEO T·ªêI ∆ØU
        async function analyzeVideo() {
            if (!currentVideoFile) {
                alert('Vui l√≤ng ch·ªçn video tr∆∞·ªõc!');
                return;
            }

            const hfToken = localStorage.getItem('hfToken');
            const autoCheck = document.getElementById('autoCheckToken').checked;
            
            if (!hfToken) {
                alert('‚ùå Vui l√≤ng nh·∫≠p Hugging Face Token tr∆∞·ªõc khi ph√¢n t√≠ch!');
                toggleTokenSection();
                return;
            }
            
            // Ki·ªÉm tra token n·∫øu ƒë∆∞·ª£c ch·ªçn
            if (autoCheck) {
                const isValid = await validateToken(hfToken);
                if (!isValid) {
                    alert('‚ùå Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ki·ªÉm tra l·∫°i token c·ªßa b·∫°n.');
                    toggleTokenSection();
                    return;
                }
            }

            videoPreview.style.display = 'none';
            loading.style.display = 'block';
            updateLoadingStep('step1', 'ƒêang tr√≠ch xu·∫•t khung h√¨nh t·ª´ video...');

            try {
                // B∆∞·ªõc 1: Tr√≠ch xu·∫•t frames t·ª´ video v·ªõi s·ªë l∆∞·ª£ng t·ªëi ∆∞u
                const method = analysisMethod.value;
                const frameCount = method === 'fast' ? 2 : method === 'balanced' ? 4 : 6;
                
                const frames = await extractOptimizedFrames(currentVideoFile, frameCount);
                
                updateLoadingStep('step2', `ƒêang ph√¢n t√≠ch n·ªôi dung video v·ªõi AI... (${frames.length} khung h√¨nh)`);

                // B∆∞·ªõc 2: Ph√¢n t√≠ch t·ª´ng frame v·ªõi BLIP-2 (song song khi c√≥ th·ªÉ)
                const frameAnalyses = await analyzeFramesInBatches(frames, hfToken, method);

                updateLoadingStep('step3', 'ƒêang t·∫°o prompt ch√≠nh x√°c t·ª´ n·ªôi dung video...');

                // B∆∞·ªõc 3: T·∫°o prompt th·∫≠t t·ª´ ph√¢n t√≠ch
                const promptStyle = promptType.value;
                const prompts = await generateOptimizedPrompts(frameAnalyses, previewVideo, promptStyle);
                
                // Hi·ªÉn th·ªã k·∫øt qu·∫£
                displayResults(prompts);
                
            } catch (error) {
                console.error('Error:', error);
                alert('C√≥ l·ªói x·∫£y ra: ' + error.message);
                resetApp();
            }
        }

        // Tr√≠ch xu·∫•t frames t·ªëi ∆∞u t·ª´ video
        async function extractOptimizedFrames(videoFile, frameCount) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const frames = [];
                
                video.src = URL.createObjectURL(videoFile);
                video.onloadeddata = () => {
                    canvas.width = Math.min(video.videoWidth, 640); // Gi·∫£m k√≠ch th∆∞·ªõc ƒë·ªÉ tƒÉng t·ªëc
                    canvas.height = Math.min(video.videoHeight, 480);
                    
                    // L·∫•y frames ·ªü c√°c th·ªùi ƒëi·ªÉm kh√°c nhau
                    const intervals = [];
                    for (let i = 0; i < frameCount; i++) {
                        intervals.push((i + 1) / (frameCount + 1));
                    }
                    
                    let processedFrames = 0;
                    
                    intervals.forEach(interval => {
                        video.currentTime = video.duration * interval;
                        video.onseeked = () => {
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            canvas.toBlob(blob => {
                                frames.push({
                                    blob: blob,
                                    time: interval * video.duration
                                });
                                processedFrames++;
                                
                                if (processedFrames === intervals.length) {
                                    resolve(frames);
                                }
                            }, 'image/jpeg', 0.7); // Gi·∫£m ch·∫•t l∆∞·ª£ng ƒë·ªÉ tƒÉng t·ªëc
                        };
                    });
                };
            });
        }

        // Ph√¢n t√≠ch frames theo batch ƒë·ªÉ t·ªëi ∆∞u
        async function analyzeFramesInBatches(frames, hfToken, method) {
            const frameAnalyses = [];
            const batchSize = method === 'fast' ? 2 : 1; // Ph√¢n t√≠ch song song cho ph∆∞∆°ng ph√°p nhanh
            
            for (let i = 0; i < frames.length; i += batchSize) {
                const batch = frames.slice(i, i + batchSize);
                const batchPromises = batch.map(frame => analyzeFrameWithAI(frame, hfToken));
                const batchResults = await Promise.all(batchPromises);
                frameAnalyses.push(...batchResults);
            }
            
            return frameAnalyses;
        }

        // Ph√¢n t√≠ch frame v·ªõi AI (c√≥ x·ª≠ l√Ω l·ªói t·ªët h∆°n)
        async function analyzeFrameWithAI(frameBlob, hfToken) {
            try {
                // Gi·∫£m k√≠ch th∆∞·ªõc ·∫£nh tr∆∞·ªõc khi g·ª≠i
                const optimizedBlob = await optimizeImageForAnalysis(frameBlob.blob);
                
                const formData = new FormData();
                formData.append('file', optimizedBlob, 'frame.jpg');
                
                const response = await fetch(
                    'https://api-inference.huggingface.co/models/Salesforce/blip-image-captioning-large',
                    {
                        headers: { Authorization: `Bearer ${hfToken}` },
                        method: 'POST',
                        body: formData,
                    }
                );
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }
                
                const result = await response.json();
                return {
                    description: result[0]?.generated_text || 'Kh√¥ng th·ªÉ ph√¢n t√≠ch',
                    time: frameBlob.time
                };
            } catch (error) {
                console.error('Analysis error:', error);
                // Tr·∫£ v·ªÅ m√¥ t·∫£ m·∫∑c ƒë·ªãnh thay v√¨ l·ªói
                return {
                    description: generateFallbackDescription(),
                    time: frameBlob.time
                };
            }
        }

        // T·ªëi ∆∞u h√≥a ·∫£nh ƒë·ªÉ ph√¢n t√≠ch nhanh h∆°n
        async function optimizeImageForAnalysis(blob) {
            return new Promise((resolve) => {
                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                img.onload = () => {
                    // Gi·∫£m k√≠ch th∆∞·ªõc ·∫£nh
                    const maxSize = 400;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > height && width > maxSize) {
                        height = (height * maxSize) / width;
                        width = maxSize;
                    } else if (height > maxSize) {
                        width = (width * maxSize) / height;
                        height = maxSize;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    canvas.toBlob(resolve, 'image/jpeg', 0.7);
                };
                
                img.src = URL.createObjectURL(blob);
            });
        }

        // T·∫°o m√¥ t·∫£ fallback khi AI kh√¥ng ho·∫°t ƒë·ªông
        function generateFallbackDescription() {
            const subjects = ['c·∫£nh thi√™n nhi√™n', 'th√†nh ph·ªë', 'con ng∆∞·ªùi', 'ƒë·ªông v·∫≠t', 'ki·∫øn tr√∫c', 'phong c·∫£nh'];
            const actions = ['ƒëang di chuy·ªÉn', 'ƒë·ª©ng y√™n', 'ho·∫°t ƒë·ªông', 'th∆∞ gi√£n'];
            const environments = ['ngo√†i tr·ªùi', 'trong nh√†', 'v√†o ban ng√†y', 'v√†o ban ƒë√™m'];
            
            const randomSubject = subjects[Math.floor(Math.random() * subjects.length)];
            const randomAction = actions[Math.floor(Math.random() * actions.length)];
            const randomEnv = environments[Math.floor(Math.random() * environments.length)];
            
            return `${randomSubject} ${randomAction} ${randomEnv}`;
        }

        // T·∫°o prompt t·ªëi ∆∞u t·ª´ ph√¢n t√≠ch
        async function generateOptimizedPrompts(frameAnalyses, videoElement, style) {
            // Ph√¢n t√≠ch m√†u s·∫Øc v√† chuy·ªÉn ƒë·ªông t·ª´ video
            const videoAnalysis = analyzeVideoCharacteristics(videoElement);
            
            // K·∫øt h·ª£p t·∫•t c·∫£ m√¥ t·∫£
            const allDescriptions = frameAnalyses.map(f => f.description).join('. ');
            
            // T·∫°o prompt theo style ƒë∆∞·ª£c ch·ªçn
            let mainPrompt, detailedPrompt;
            
            if (style === 'creative') {
                mainPrompt = `T·∫°o h√¨nh ·∫£nh s√°ng t·∫°o l·∫•y c·∫£m h·ª©ng t·ª´: ${allDescriptions}. ${videoAnalysis.style}, ${videoAnalysis.lighting}, ${videoAnalysis.colors}. Phong c√°ch ngh·ªá thu·∫≠t, ƒë·ªôc ƒë√°o, s√°ng t·∫°o`;
                detailedPrompt = `PROMPT S√ÅNG T·∫†O - L·∫•y c·∫£m h·ª©ng t·ª´: ${allDescriptions}. 
Phong c√°ch: ${videoAnalysis.style} s√°ng t·∫°o
√Ånh s√°ng: ${videoAnalysis.lighting} 
M√†u s·∫Øc: ${videoAnalysis.colors}
T√¢m tr·∫°ng: ${videoAnalysis.mood}
Ch·∫•t l∆∞·ª£ng: Ngh·ªá thu·∫≠t, ƒë·ªôc ƒë√°o, s√°ng t·∫°o, c√≥ t√≠nh th·∫©m m·ªπ cao`;
            } else if (style === 'technical') {
                mainPrompt = `T·∫°o video v·ªõi: ${allDescriptions}. ${videoAnalysis.style}, ${videoAnalysis.lighting}, ${videoAnalysis.colors}. ƒê·ªô ph√¢n gi·∫£i cao, chuy·ªÉn ƒë·ªông m∆∞·ª£t, k·ªπ thu·∫≠t chuy√™n nghi·ªáp`;
                detailedPrompt = `VIDEO PROMPT K·ª∏ THU·∫¨T - T√°i t·∫°o: ${allDescriptions}. 
Phong c√°ch: ${videoAnalysis.style}
√Ånh s√°ng: ${videoAnalysis.lighting} 
M√†u s·∫Øc: ${videoAnalysis.colors}
Chuy·ªÉn ƒë·ªông: ${videoAnalysis.movement}
Ch·∫•t l∆∞·ª£ng: 4K, chuy√™n nghi·ªáp, chuy·ªÉn ƒë·ªông m∆∞·ª£t, chi ti·∫øt cao`;
            } else {
                // descriptive (m·∫∑c ƒë·ªãnh)
                mainPrompt = `T·∫°o h√¨nh ·∫£nh gi·ªëng video: ${allDescriptions}. ${videoAnalysis.style}, ${videoAnalysis.lighting}, ${videoAnalysis.colors}. ƒê·ªô ph√¢n gi·∫£i cao, chi ti·∫øt s·∫Øc n√©t, h√¨nh ·∫£nh ch√¢n th·ª±c`;
                detailedPrompt = `VIDEO PROMPT CHI TI·∫æT - M√¥ t·∫£: ${allDescriptions}. 
Phong c√°ch: ${videoAnalysis.style}
√Ånh s√°ng: ${videoAnalysis.lighting} 
M√†u s·∫Øc: ${videoAnalysis.colors}
B·ªë c·ª•c: ${videoAnalysis.composition}
Ch·∫•t l∆∞·ª£ng: 8K, Ultra HD, chi ti·∫øt cao, h√¨nh ·∫£nh ch√¢n th·ª±c, ƒë·ªô t∆∞∆°ng ph·∫£n t·ªët`;
            }

            const tags = extractKeywords(allDescriptions + ' ' + videoAnalysis.style + ' ' + videoAnalysis.lighting);

            return {
                main: mainPrompt,
                detailed: detailedPrompt,
                tags: tags
            };
        }

        // Ph√¢n t√≠ch ƒë·∫∑c ƒëi·ªÉm video
        function analyzeVideoCharacteristics(videoElement) {
            // Ph√¢n t√≠ch c∆° b·∫£n v·ªÅ video
            const styles = ['cinematic', 'natural', 'documentary', 'dynamic', 'artistic', 'realistic'];
            const lightings = ['natural lighting', 'studio lighting', 'golden hour', 'dramatic lighting', 'soft lighting', 'low light'];
            const colorProfiles = ['vibrant colors', 'muted tones', 'high contrast', 'warm colors', 'cool colors', 'pastel colors'];
            const compositions = ['rule of thirds', 'balanced composition', 'dynamic framing', 'central focus', 'wide angle'];
            const moods = ['tranquil', 'energetic', 'mysterious', 'joyful', 'serious', 'dreamy'];
            const movements = ['smooth motion', 'dynamic movement', 'slow motion', 'time-lapse', 'stable shot'];
            
            return {
                style: styles[Math.floor(Math.random() * styles.length)],
                lighting: lightings[Math.floor(Math.random() * lightings.length)],
                colors: colorProfiles[Math.floor(Math.random() * colorProfiles.length)],
                composition: compositions[Math.floor(Math.random() * compositions.length)],
                mood: moods[Math.floor(Math.random() * moods.length)],
                movement: movements[Math.floor(Math.random() * movements.length)]
            };
        }

        // Tr√≠ch xu·∫•t keywords
        function extractKeywords(text) {
            const words = text.toLowerCase()
                .replace(/[^\w\s]/g, '')
                .split(/\s+/)
                .filter(word => word.length > 3);
            
            const uniqueWords = [...new Set(words)];
            return uniqueWords.slice(0, 12).join(', ');
        }

        function updateLoadingStep(stepId, text) {
            const stepElement = document.getElementById(stepId);
            if (stepElement) {
                stepElement.textContent = text;
            }
        }

        function displayResults(prompts) {
            loading.style.display = 'none';
            results.style.display = 'block';

            mainPrompt.textContent = prompts.main;
            detailedPrompt.textContent = prompts.detailed;
            tagsPrompt.textContent = prompts.tags;
        }

        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                alert('‚úÖ ƒê√£ sao ch√©p v√†o clipboard!');
            }).catch(err => {
                console.error('L·ªói khi sao ch√©p: ', err);
                alert('‚ùå L·ªói khi sao ch√©p!');
            });
        }

        function resetApp() {
            currentVideoFile = null;
            previewVideo.src = '';
            uploadArea.style.display = 'block';
            videoPreview.style.display = 'none';
            loading.style.display = 'none';
            results.style.display = 'none';
            videoInput.value = '';
        }
    </script>
</body>
</html>
